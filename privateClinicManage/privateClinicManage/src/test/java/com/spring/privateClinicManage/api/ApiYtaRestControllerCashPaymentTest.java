package com.spring.privateClinicManage.api;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import com.spring.privateClinicManage.dto.CashPaymentDto;
import com.spring.privateClinicManage.entity.MedicalExamination;
import com.spring.privateClinicManage.entity.MedicalRegistryList;
import com.spring.privateClinicManage.entity.StatusIsApproved;
import com.spring.privateClinicManage.entity.User;
import com.spring.privateClinicManage.service.DownloadPDFService;
import com.spring.privateClinicManage.service.MailSenderService;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import com.spring.privateClinicManage.service.MedicalExaminationService;
import com.spring.privateClinicManage.service.MedicalRegistryListService;
import com.spring.privateClinicManage.service.PaymentDetailPhase1Service;
import com.spring.privateClinicManage.service.PaymentDetailPhase2Service;
import com.spring.privateClinicManage.service.StatusIsApprovedService;
import com.spring.privateClinicManage.service.UserService;

/**
 * Unit tests for ApiYtaRestController's cash payment functionality
 * This class tests the cash payment methods in the nurse/staff API controller
 *
 * Các test case kiểm tra chức năng thanh toán tiền mặt:
 * - Thanh toán tiền mặt giai đoạn 1 (thanh toán đăng ký)
 * - Thanh toán tiền mặt giai đoạn 2 (thanh toán khám bệnh)
 * - Xử lý các trường hợp lỗi: user không tồn tại, phiếu khám không tồn tại, trạng thái không hợp lệ
 */
@ExtendWith(MockitoExtension.class)
public class ApiYtaRestControllerCashPaymentTest {

    @Mock
    private UserService userService;

    @Mock
    private MedicalRegistryListService medicalRegistryListService;

    @Mock
    private PaymentDetailPhase1Service paymentDetailPhase1Service;

    @Mock
    private PaymentDetailPhase2Service paymentDetailPhase2Service;

    @Mock
    private StatusIsApprovedService statusIsApprovedService;

    @Mock
    private MedicalExaminationService medicalExaminationService;

    @Mock
    private DownloadPDFService downloadPDFService;

    @Mock
    private MailSenderService mailSenderService;

    @Mock
    private SimpMessagingTemplate messagingTemplate;

    @InjectMocks
    private ApiYtaRestController apiYtaRestController;

    // Test data
    private User user;
    private MedicalRegistryList mrl;
    private MedicalExamination me;
    private StatusIsApproved statusPaymentPhase1;
    private StatusIsApproved statusPaymentPhase2;
    private StatusIsApproved statusSuccess;
    private StatusIsApproved statusFinished;
    private CashPaymentDto cashPaymentDto;

    /**
     * Setup test data before each test
     * Khởi tạo dữ liệu test cho các test case
     * Bao gồm các đối tượng User, MedicalRegistryList, MedicalExamination, StatusIsApproved và CashPaymentDto
     */
    @BeforeEach
    void setUp() {
        // Initialize test data
        user = new User();
        user.setId(1);
        user.setName("Test User");
        user.setEmail("test@example.com");

        statusPaymentPhase1 = new StatusIsApproved();
        statusPaymentPhase1.setId(1);
        statusPaymentPhase1.setStatus("PAYMENTPHASE1");

        statusPaymentPhase2 = new StatusIsApproved();
        statusPaymentPhase2.setId(2);
        statusPaymentPhase2.setStatus("PAYMENTPHASE2");

        statusSuccess = new StatusIsApproved();
        statusSuccess.setId(3);
        statusSuccess.setStatus("SUCCESS");

        statusFinished = new StatusIsApproved();
        statusFinished.setId(4);
        statusFinished.setStatus("FINISHED");

        mrl = new MedicalRegistryList();
        mrl.setId(100);
        mrl.setUser(user);
        mrl.setStatusIsApproved(statusPaymentPhase1);
        mrl.setIsCanceled(false);

        me = new MedicalExamination();
        me.setId(200);
        me.setMrl(mrl);
        me.setFollowUpDate(null);

        cashPaymentDto = new CashPaymentDto();
        cashPaymentDto.setMrlId(100);
        cashPaymentDto.setAmount(100000L);
    }

    /**
     * Test case: TC_CASH_01
     * Test cash payment for phase 1 (registration payment)
     * Input: Valid CashPaymentDto for a medical registry in PAYMENTPHASE1 status
     * Expected output: ResponseEntity with HTTP 200 and success message
     *
     * Mục tiêu: Kiểm tra thanh toán tiền mặt cho giai đoạn 1 (đăng ký khám)
     * Đầu vào: CashPaymentDto hợp lệ cho phiếu khám ở trạng thái PAYMENTPHASE1
     * Đầu ra mong đợi: ResponseEntity với HTTP 200 và thông báo thành công
     */
    @Test
    @DisplayName("TC_CASH_01: Cash payment for phase 1 (registration payment)")
    void testCashPaymentMrl_Phase1() throws Exception {
        // Arrange
        when(userService.getCurrentLoginUser()).thenReturn(user);
        when(medicalRegistryListService.findById(anyInt())).thenReturn(mrl);
        when(statusIsApprovedService.findByStatus("SUCCESS")).thenReturn(statusSuccess);
        doNothing().when(paymentDetailPhase1Service).savePdp1(any());
        doNothing().when(medicalRegistryListService).createQRCodeAndUpLoadCloudinaryAndSetStatus(any(), any());
        doNothing().when(mailSenderService).sendStatusRegisterEmail(any(), anyString(), any());
        doNothing().when(messagingTemplate).convertAndSend(eq("/notify/cashSuccesfully/" + user.getId()), any(MedicalRegistryList.class));

        // Act
        ResponseEntity<Object> response = apiYtaRestController.cashPaymentMrl(cashPaymentDto);

        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals("Thanh toán thành công !", response.getBody());

        // Verify service calls
        verify(userService).getCurrentLoginUser();
        verify(medicalRegistryListService).findById(100);
        verify(paymentDetailPhase1Service).savePdp1(any());
        verify(statusIsApprovedService).findByStatus("SUCCESS");
        verify(medicalRegistryListService).createQRCodeAndUpLoadCloudinaryAndSetStatus(eq(mrl), eq(statusSuccess));
    }

    /**
     * Test case: TC_CASH_02
     * Test cash payment for phase 2 (examination payment)
     * Input: Valid CashPaymentDto for a medical registry in PAYMENTPHASE2 status
     * Expected output: ResponseEntity with HTTP 200 and success message
     *
     * Mục tiêu: Kiểm tra thanh toán tiền mặt cho giai đoạn 2 (khám bệnh)
     * Đầu vào: CashPaymentDto hợp lệ cho phiếu khám ở trạng thái PAYMENTPHASE2
     * Đầu ra mong đợi: ResponseEntity với HTTP 200 và thông báo thành công
     */
    @Test
    @DisplayName("TC_CASH_02: Cash payment for phase 2 (examination payment)")
    void testCashPaymentMrl_Phase2() throws Exception {
        // Arrange
        mrl.setStatusIsApproved(statusPaymentPhase2);
        mrl.setMedicalExamination(me);

        when(userService.getCurrentLoginUser()).thenReturn(user);
        when(medicalRegistryListService.findById(anyInt())).thenReturn(mrl);
        when(statusIsApprovedService.findByStatus("FINISHED")).thenReturn(statusFinished);
        doNothing().when(paymentDetailPhase2Service).savePdp2(any());
        doNothing().when(mailSenderService).sendStatusRegisterEmail(any(), anyString(), any());
        doNothing().when(messagingTemplate).convertAndSend(eq("/notify/cashSuccesfully/" + user.getId()), any(MedicalRegistryList.class));

        // Act
        ResponseEntity<Object> response = apiYtaRestController.cashPaymentMrl(cashPaymentDto);

        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals("Thanh toán thành công !", response.getBody());

        // Verify service calls
        verify(userService).getCurrentLoginUser();
        verify(medicalRegistryListService).findById(100);
        verify(paymentDetailPhase2Service).savePdp2(any());
        verify(statusIsApprovedService).findByStatus("FINISHED");
    }

    /**
     * Test case: TC_CASH_03
     * Test cash payment with non-existent user
     * Input: Valid CashPaymentDto but user not found
     * Expected output: ResponseEntity with HTTP 404 and error message
     *
     * Mục tiêu: Kiểm tra xử lý lỗi khi user không tồn tại
     * Đầu vào: CashPaymentDto hợp lệ nhưng user không tồn tại
     * Đầu ra mong đợi: ResponseEntity với HTTP 404 và thông báo lỗi
     */
    @Test
    @DisplayName("TC_CASH_03: Cash payment with non-existent user")
    void testCashPaymentMrl_UserNotFound() {
        // Arrange
        when(userService.getCurrentLoginUser()).thenReturn(null);
        // The controller calls findById before checking if user is null
        when(medicalRegistryListService.findById(anyInt())).thenReturn(mrl);

        // Act
        ResponseEntity<Object> response = apiYtaRestController.cashPaymentMrl(cashPaymentDto);

        // Assert
        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Người dùng không tồn tại"));

        // Verify service calls
        verify(userService).getCurrentLoginUser();
        // The controller calls findById even if user is null
        verify(medicalRegistryListService).findById(anyInt());
    }

    /**
     * Test case: TC_CASH_04
     * Test cash payment with non-existent medical registry
     * Input: Valid CashPaymentDto but medical registry not found
     * Expected output: ResponseEntity with HTTP 404 and error message
     *
     * Mục tiêu: Kiểm tra xử lý lỗi khi phiếu khám không tồn tại
     * Đầu vào: CashPaymentDto hợp lệ nhưng phiếu khám không tồn tại
     * Đầu ra mong đợi: ResponseEntity với HTTP 404 và thông báo lỗi
     */
    @Test
    @DisplayName("TC_CASH_04: Cash payment with non-existent medical registry")
    void testCashPaymentMrl_MrlNotFound() {
        // Arrange
        when(userService.getCurrentLoginUser()).thenReturn(user);
        when(medicalRegistryListService.findById(anyInt())).thenReturn(null);

        // Act
        ResponseEntity<Object> response = apiYtaRestController.cashPaymentMrl(cashPaymentDto);

        // Assert
        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Người dùng không tồn tại hoặc đơn đăng ký không tồn tại"));

        // Verify service calls
        verify(userService).getCurrentLoginUser();
        verify(medicalRegistryListService).findById(100);
    }

    /**
     * Test case: TC_CASH_05
     * Test cash payment with invalid medical registry status
     * Input: Valid CashPaymentDto but medical registry has invalid status
     * Expected output: ResponseEntity with HTTP 401 and error message
     *
     * Mục tiêu: Kiểm tra xử lý lỗi khi trạng thái phiếu khám không hợp lệ
     * Đầu vào: CashPaymentDto hợp lệ nhưng phiếu khám có trạng thái không hợp lệ
     * Đầu ra mong đợi: ResponseEntity với HTTP 401 và thông báo lỗi
     */
    @Test
    @DisplayName("TC_CASH_05: Cash payment with invalid medical registry status")
    void testCashPaymentMrl_InvalidStatus() {
        // Arrange
        StatusIsApproved invalidStatus = new StatusIsApproved();
        invalidStatus.setId(5);
        invalidStatus.setStatus("PENDING");

        mrl.setStatusIsApproved(invalidStatus);

        when(userService.getCurrentLoginUser()).thenReturn(user);
        when(medicalRegistryListService.findById(anyInt())).thenReturn(mrl);

        // Act
        ResponseEntity<Object> response = apiYtaRestController.cashPaymentMrl(cashPaymentDto);

        // Assert
        assertEquals(HttpStatus.UNAUTHORIZED, response.getStatusCode());
        assertEquals("Trạng thái phiếu đăng ký không hợp lệ", response.getBody());

        // Verify service calls
        verify(userService).getCurrentLoginUser();
        verify(medicalRegistryListService).findById(100);
        verify(paymentDetailPhase1Service, never()).savePdp1(any());
        verify(paymentDetailPhase2Service, never()).savePdp2(any());
    }
}
